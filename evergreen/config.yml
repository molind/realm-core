# Evergreen CI config script for the Realm Core codebase
# Run types:
# * Pull Requests:
#   * add the "for_pull_requests" tag to the task to run for pull requests
# * Nightly Builds:
#   * Add the `"for_nightly_tests"` tag to the task for the "nightly_tests" alias to work
#   * Add the `allowed_requesters: [ "ad_hoc", "patch" ]` entry to the nightly task to only run for periodic tests
# * Commit Builds:
#   * All other tasks will be included in the set run when a PR is merged to master
# * To prevent a task from running at all, add the `"disabled"` tag so it will be skipped by the any of the test runs.

# Some tests take up to 4 hours to run, so give a very generous timeout project-wide, but generally try to complete tasks within 30 minutes.
exec_timeout_secs: 14400

functions:
  "fetch binaries":
    - command: shell.exec
      params:
        working_dir: realm-core
        shell: bash
        script: |-
          set -o errexit
          set -o pipefail
          set -o verbose

          if [[ "$OS" = "Windows_NT" ]]; then
            curl -LsSo cmake_binaries.zip ${cmake_url}
            unzip -q cmake_binaries.zip
          else
            mkdir cmake_binaries && cd cmake_binaries
            curl -LsS ${cmake_url} | tar -xz --strip-components=1
            cd ..
          fi

          if [[ -n "${clang_url|}" ]]; then
            mkdir clang_binaries && cd clang_binaries
            curl -LsS ${clang_url} | tar -xJ --strip-components=1
            cd ..
          fi

  "fetch source":
    - command: git.get_project
      params: {directory: realm-core}
    - command: shell.exec
      params:
        working_dir: realm-core
        script: |-
          set -o errexit
          git submodule update --init --recursive

  "compile":
    - command: shell.exec
      params:
        working_dir: realm-core
        shell: bash
        script: |-
          set -o errexit
          set -o pipefail
          set -o verbose

          if [ -d cmake_vars ]; then
              rm cmake_vars/*.txt
          fi
          export CMAKE_VARS_DIR=$(./evergreen/abspath.sh cmake_vars)
          source evergreen/cmake_vars_utils.sh
          export CMAKE=$(./evergreen/abspath.sh ${cmake_bindir}/cmake)

          if [ -n "${xcode_developer_dir}" ]; then
              export DEVELOPER_DIR="${xcode_developer_dir}"
          fi

          if [ -n "${c_compiler}" ]; then
              [ -n "${cxx_compiler}" ] || (echo "C compiler defined as  but C++ compiler is undefined"; exit 1)
              set_cmake_var compiler_vars CMAKE_C_COMPILER PATH $(./evergreen/abspath.sh ${c_compiler})
              set_cmake_var compiler_vars CMAKE_CXX_COMPILER PATH $(./evergreen/abspath.sh ${cxx_compiler})
          fi

          if [ -z "${disable_tests_against_baas|}" ]; then
              scheme="http"
              set_cmake_var baas_vars REALM_ENABLE_AUTH_TESTS BOOL On
              set_cmake_var baas_vars REALM_MONGODB_ENDPOINT STRING "$scheme://localhost:9090"
              if [ -n "${baas_admin_port|}" ]; then
                set_cmake_var baas_vars REALM_ADMIN_ENDPOINT STRING "$scheme://localhost:${baas_admin_port}"
              fi
          fi

          if [ -n "${enable_asan|}" ]; then
              set_cmake_var realm_vars REALM_ASAN BOOL On
          fi

          if [ -n "${enable_tsan|}" ]; then
              set_cmake_var realm_vars REALM_TSAN BOOL On
          fi

          if [ -n "${enable_ubsan|}" ]; then
              set_cmake_var realm_vars REALM_USAN BOOL On
          fi

          if [ -n "${enable_valgrind|}" ]; then
              set_cmake_var realm_vars REALM_VALGRIND BOOL On
              set_cmake_var realm_vars REALM_ENABLE_ALLOC_SET_ZERO BOOL On
          fi

          if [ -n "${enable_fuzzer|}" ]; then
              set_cmake_var realm_vars REALM_LIBFUZZER BOOL On
          fi

          if [ -z "${disable_sync|}" ]; then
              set_cmake_var realm_vars REALM_ENABLE_SYNC BOOL On
          fi

          if [ -n "${use_system_openssl|}" ]; then
              set_cmake_var realm_vars REALM_USE_SYSTEM_OPENSSL BOOL On
          fi

          if [ -n "${long_running_test_duration|}" ]; then
              set_cmake_var realm_vars REALM_TEST_DURATION STRING "${long_running_test_duration}"
          fi

          if [ -n "${disable_sync_multiplexing|}" ]; then
              set_cmake_var realm_vars REALM_SYNC_MULTIPLEXING BOOL Off
          fi

          if [ -n "${enable_llvm_coverage|}" ]; then
              set_cmake_var realm_vars REALM_LLVM_COVERAGE BOOL On
          fi

          set_cmake_var realm_vars REALM_BUILD_COMMANDLINE_TOOLS BOOL On
          set_cmake_var realm_vars REALM_ENABLE_ENCRYPTION BOOL On

          if [[ -n "${fetch_missing_dependencies|}" ]]; then
              set_cmake_var realm_vars REALM_FETCH_MISSING_DEPENDENCIES BOOL On
          fi

          if [[ -n "${cmake_toolchain_file|}" ]]; then
              set_cmake_var realm_vars CMAKE_TOOLCHAIN_FILE PATH "${cmake_toolchain_file}"
          fi

          set_cmake_var realm_vars REALM_TEST_LOGGING BOOL On
          set_cmake_var realm_vars REALM_TEST_LOGGING_LEVEL STRING "${test_logging_level|debug}"

          if [[ -n "${test_timeout_extra|}" ]]; then
              set_cmake_var realm_vars REALM_TEST_TIMEOUT_EXTRA STRING ${test_timeout_extra}
          fi

          GENERATOR="${cmake_generator}"
          if [ -z "${cmake_generator|}" ]; then
              GENERATOR="Ninja Multi-Config"
              set_cmake_var generator_vars CMAKE_MAKE_PROGRAM PATH "${ninja|ninja}"
          fi

          if [ -n "${cmake_generator_platform|}" ]; then
            set_cmake_var realm_vars CMAKE_GENERATOR_PLATFORM STRING "${cmake_generator_platform}"
          fi

          if [ -n "${curl_base|}" ]; then
              set_cmake_var curl_vars CURL_LIBRARY PATH "$(./evergreen/abspath.sh ${curl_base}/lib/libcurl.dll.a)"
              set_cmake_var curl_vars CURL_INCLUDE_DIR PATH "$(./evergreen/abspath.sh ${curl_base}/include)"
              set_cmake_var baas_vars REALM_CURL_CACERTS PATH "$(./evergreen/abspath.sh "${curl_base}/bin/cacert.pem")"
          fi

          set_cmake_var realm_vars REALM_NO_TESTS BOOL ${no_tests|Off}

          echo "Running cmake with these vars:"
          cat cmake_vars/*.txt | tee cmake_vars.txt
          echo

          $CMAKE \
            -B build \
            -C cmake_vars.txt ${extra_flags} \
            -G "$GENERATOR"

          if [[ -n "${target_to_build|}" ]]; then
              target="--target ${target_to_build|}"
          fi

          ${cmake_bindir}/cmake \
              --build build \
              --config ${cmake_build_type|Debug} \
              -j ${max_jobs|$(grep -c proc /proc/cpuinfo)} \
              $target

  "run benchmark":
    - command: shell.exec
      params:
        working_dir: realm-core
        shell: bash
        script: |-
          set -o errexit

          if [[ -z "${benchmark_name}" ]]; then
              echo "No benchmark specified."
              exit 1
          fi

          export UNITTEST_THREADS=1

          BENCHMARK=$(./evergreen/abspath.sh ./build/test/benchmark-${benchmark_name}/${cmake_build_type|Debug}/realm-benchmark-${benchmark_name})
          echo "Going to run benchmark $BENCHMARK"

          [[ -d benchmark_results ]] && rm -rf benchmark_results
          mkdir benchmark_results
          cd benchmark_results

          $BENCHMARK "$(pwd)/"
    - command: perf.send
      params:
        file: './realm-core/benchmark_results/results.latest.json'

  "run tests":
    - command: shell.exec
      params:
        working_dir: realm-core
        shell: bash
        script: |-
          set -o errexit
          set -o verbose
          CTEST=$(pwd)/${cmake_bindir}/ctest

          if [ -n "${xcode_developer_dir}" ]; then
              export DEVELOPER_DIR="${xcode_developer_dir}"
          fi

          if [[ -n "${curl_base}" ]]; then
              export PATH="${curl_base}/bin":$PATH
          fi

          # NOTE: These two values will be ANDed together for matching tests
          TEST_FLAGS=
          if [[ -n "${test_label}" ]]; then
              TEST_FLAGS="-L ${test_label} "
          fi
          if [[ -n "${test_filter}" ]]; then
              TEST_FLAGS+="-R ${test_filter} "
          fi

          if [[ -n "${verbose_test_output}" ]]; then
              TEST_FLAGS="$TEST_FLAGS -VV"
              export UNITTEST_THREADS=1
              export UNITTEST_LOG_LEVEL="${test_logging_level|debug}"
          else
              TEST_FLAGS="$TEST_FLAGS -V"
          fi

          TEST_FLAGS="--no-tests=error $TEST_FLAGS ${test_flags|}"

          if [[ -n "${llvm_symbolizer}" ]]; then
              export ASAN_SYMBOLIZER_PATH="$(./evergreen/abspath.sh ${llvm_symbolizer})"
          fi
          if [[ -n "${enable_llvm_coverage}" ]]; then
              if [[ -z "${test_executable_name}" ]]; then
                echo "Missing executable name"
                exit 1
              fi
              [[ -d coverage_data ]] || mkdir coverage_data
              [[ -d coverage_binaries ]] || mkdir coverage_binaries
              export LLVM_PROFILE_FILE="$(pwd)/coverage_data/${task_name}-%p.profraw"
              EXECUTABLE_FILE="$(find build -name "${test_executable_name}" -type f)"
              EXECUTABLE_PATH="$(./evergreen/abspath.sh "$EXECUTABLE_FILE")"
              if [[ -z "$EXECUTABLE_PATH" || ! -f "$EXECUTABLE_PATH" ]]; then
                echo "Invalid executable path $EXECUTABLE_PATH"
                exit 1
              fi
              # The sym link may have been created by a previous task run
              if [[ ! -f "coverage_binaries/${test_executable_name}" ]]; then
                ln -s "$EXECUTABLE_PATH" "coverage_binaries/${test_executable_name}"
              fi
          fi

          export UNITTEST_EVERGREEN_TEST_RESULTS="$(./evergreen/abspath.sh ${task_name}_results.json)"
          if [[ -n "$UNITTEST_EVERGREEN_TEST_RESULTS" && -f "$UNITTEST_EVERGREEN_TEST_RESULTS" ]]; then
              rm "$UNITTEST_EVERGREEN_TEST_RESULTS"
          fi
          export UNITTEST_PROGRESS=1

          if [[ -n "${run_with_encryption}" ]]; then
              export UNITTEST_ENCRYPT_ALL=1
          fi
          export TSAN_OPTIONS="suppressions=$(pwd)/test/tsan.suppress history_size=4"
          export UBSAN_OPTIONS="print_stacktrace=1"

          cd build
          if ! $CTEST -C ${cmake_build_type|Debug} $TEST_FLAGS; then
            BAAS_PID=$(pgrep baas_server)
            if [[ -n "$BAAS_PID" ]]; then
              echo "Dumping baas to log file"
              kill -3 $BAAS_PID
              sleep 15
            fi
            exit 1
          fi

  "upload test results":
  - command: attach.results
    params:
      file_location: realm-core/${task_name}_results.json

  "upload baas artifacts":
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: bash
      script: |-
        set -o errexit
        set -o pipefail
        set -o verbose

        if [[ -n "${disable_tests_against_baas|}" ]]; then
          exit 0
        fi

        # Copy the baas_server log from the remote baas host if it exists
        if [[ ! -f baas_host.yml || ! -f .baas_ssh_key ]]; then
          echo "Skipping - no remote baas host or remote baas host definitions not found"
          exit 0
        fi

        BAAS_HOST_NAME=$(tr -d '"[]{}' < baas_host.yml | cut -d , -f 1 | awk -F : '{print $2}')
        export BAAS_HOST_NAME

        ssh_user="$(printf "ubuntu@%s" "$BAAS_HOST_NAME")"
        ssh_options="-o ForwardAgent=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=no -o ConnectTimeout=60 -i .baas_ssh_key"

        # Copy the baas_server.log, mongod.log and (optionally) baas_proxy.log files from the remote baas host
        REMOTE_PATH=/data/baas-remote
        REMOTE_BAAS_PATH="$REMOTE_PATH/baas-work-dir"
        REMOTE_BAAS_DB_PATH="$REMOTE_BAAS_PATH/mongodb-dbpath"
        REMOTE_PROXY_PATH="$REMOTE_PATH/baas-proxy-dir"

        LOCAL_BAAS_PATH=./baas-work-dir
        LOCAL_BAAS_DB_PATH="$LOCAL_BAAS_PATH/mongodb-dbpath"
        LOCAL_PROXY_PATH=./baas-proxy-dir

        mkdir -p "$LOCAL_BAAS_PATH/"
        mkdir -p "$LOCAL_BAAS_DB_PATH/"
        mkdir -p "$LOCAL_PROXY_PATH/"
        scp $ssh_options $ssh_user:"$REMOTE_BAAS_PATH/baas_server.log" "$LOCAL_BAAS_PATH/baas_server.log" || true
        scp $ssh_options $ssh_user:"$REMOTE_BAAS_DB_PATH/mongod.log" "$LOCAL_BAAS_DB_PATH/mongod.log" || true
        scp $ssh_options $ssh_user:"$REMOTE_PROXY_PATH/baas_proxy.log" "$LOCAL_PROXY_PATH/baas_proxy.log" || true

  - command: s3.put
    params:
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      local_file: 'realm-core/baas-work-dir/baas_server.log'
      remote_file: 'realm-core-stable/${branch_name}/${task_id}/${execution}/baas_server.log'
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: baas server logs
      optional: true
  - command: s3.put
    params:
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      local_file: 'realm-core/install_baas_output.log'
      remote_file: 'realm-core-stable/${branch_name}/${task_id}/${execution}/install_baas_output.log'
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: install baas output
      optional: true
  - command: s3.put
    params:
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      local_file: 'realm-core/baas-work-dir/mongodb-dbpath/mongod.log'
      remote_file: 'realm-core-stable/${branch_name}/${task_id}/${execution}/mongod.log'
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: mongod logs
      optional: true
  - command: s3.put
    params:
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      local_file: 'realm-core/baas-proxy-dir/baas_proxy.log'
      remote_file: 'realm-core-stable/${branch_name}/${task_id}/${execution}/baas_proxy.log'
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: baas proxy logs
      optional: true

  "upload fuzzer results":
  - command: shell.exec
    params:
      working_dir: realm-core/build/test/realm-fuzzer
      script: |-
        if ls crash-*> /dev/null 2>&1; then
          echo "Found crash file"
          mv crash-* realm-fuzzer-crash.txt
        fi

  - command: s3.put
    params:
      working_dir: realm-core/build/test/realm-fuzzer
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      local_file: 'realm-core/build/test/realm-fuzzer/realm-fuzzer-crash.txt'
      remote_file: '${project}/${branch_name}/${task_id}/${execution}/realm-fuzzer-crash.txt'
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: Fuzzer crash report
      optional: true

  - command: shell.exec
    params:
      working_dir: realm-core/build/test/realm-fuzzer
      script: |-
        rm realm-fuzzer-crash.txt

  "run hang analyzer":
  - command: shell.exec
    params:
      shell: bash
      script: |-
        set -o errexit
        set -o pipefail
        set -o verbose

        if [[ -n "${disable_tests_against_baas|}" ]]; then
          exit 0
        fi

        # Kill the local baas server process, if it exists
        BAAS_PID=$(pgrep baas_server)
        if [[ -n "$BAAS_PID" ]]; then
          echo "Terminating local baas server..."
          kill -3 $BAAS_PID
          exit 0
        fi

        if [[ ! -f baas_host.yml || ! -f .baas_ssh_key ]]; then
          echo "No remote baas host or remote baas host definitions not found"
          exit 0
        fi

        BAAS_HOST_NAME=$(tr -d '"[]{}' < baas_host.yml | cut -d , -f 1 | awk -F : '{print $2}')
        export BAAS_HOST_NAME

        ssh_user="$(printf "ubuntu@%s" "$BAAS_HOST_NAME")"
        ssh_options="-o ForwardAgent=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=no -o ConnectTimeout=60 -i .baas_ssh_key"

        # Kill the remote baas server process, if the definition files exist
        echo "Terminating baas server on remote host..."
        ssh $ssh_options $ssh_user "pkill -3 baas_server"

  - command: shell.exec
    params:
      shell: bash
      script: |-
        set -o errexit
        set -o verbose

        TOP_DIR=$(pwd)/realm-core
        HANG_ANALYZER_PATH=$TOP_DIR/evergreen/hang_analyzer
        REQUIREMENTS_PATH=$HANG_ANALYZER_PATH/requirements.txt

        if [[ ! -d $TOP_DIR || ! -d $REQUIREMENTS_PATH ]]; then
          echo "No source directory exists. Not running hang analyzer"
          exit 1
        fi

        mkdir realm-core/hang_analyzer_workdir; cd realm-core/hang_analyzer_workdir
        ${python3|python3} -m venv venv

        # venv creates its Scripts/activate file with CLRF endings, which
        # cygwin bash does not like. dos2unix it
        # (See https://bugs.python.org/issue32451)
        if [ "Windows_NT" = "$OS" ]; then
          dos2unix "venv/Scripts/activate"
        fi

        export VIRTUAL_ENV_DISABLE_PROMPT=yes

        if [ "Windows_NT" = "$OS" ]; then
          # Need to quote the path on Windows to preserve the separator.
          . "venv/Scripts/activate" 2> /tmp/activate_error.log
        else
          . venv/bin/activate 2> /tmp/activate_error.log
        fi
        if [ $? -ne 0 ]; then
          echo "Failed to activate virtualenv: $(cat /tmp/activate_error.log)"
          exit 1
        fi
        python=python

        echo "python set to $(which $python)"

        echo "Upgrading pip to 21.0.1"

        # ref: https://github.com/grpc/grpc/issues/25082#issuecomment-778392661
        if [ "$(uname -m)" = "arm64" ] && [ "$(uname)" == "Darwin" ]; then
          export GRPC_PYTHON_BUILD_SYSTEM_OPENSSL=1
          export GRPC_PYTHON_BUILD_SYSTEM_ZLIB=1
        fi

        python -m pip --disable-pip-version-check install "pip==21.0.1" "wheel==0.37.0" || exit 1

        if [ "Windows_NT" = "$OS" ]; then
          REQUIREMENTS_PATH=$(cygpath -w $REQUIREMENTS_PATH)
        fi

        python -m pip install -r $REQUIREMENTS_PATH || exit 1

        echo "Going to run hang analyzer"

        if [ "Windows_NT" = "$OS" ]; then
          HANG_ANALYZER_PATH=$(cygpath -w $HANG_ANALYZER_PATH)
        fi

        python $HANG_ANALYZER_PATH

  "launch remote baas":
  - command: host.create
    params:
      provider: ec2
      distro: ubuntu2004-medium
  - command: host.list
    params:
      num_hosts: 1
      path: realm-core/baas_host.yml
      timeout_seconds: 600
      wait: true
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: bash
      # Do NOT use verbose for this script since it would reveal the values of secrets
      script: |-
        set -o errexit
        set -o pipefail

        if [[ -n "${disable_tests_against_baas|}" ]]; then
          echo "Should not be using remote baas if the tests are not being used"
          exit 0
        fi

        # Save the remote host ssh key and details to files
        echo "${__project_aws_ssh_key_value}" > .baas_ssh_key
        chmod 600 .baas_ssh_key

        BAAS_HOST_NAME=$(tr -d '"[]{}' < baas_host.yml | cut -d , -f 1 | awk -F : '{print $2}')

        # Github SSH host key updated 06/26/2023
        # Use 'github_known_hosts' expansion for GITHUB_KNOWN_HOSTS below once EVG-20410 has been implemented
        cat >baas_host_vars.sh <<EOF
        export AWS_ACCESS_KEY_ID="${baas_secrets_aws_access_key}"
        export AWS_SECRET_ACCESS_KEY="${baas_secrets_aws_secret_key}"
        export BAAS_HOST_NAME="$BAAS_HOST_NAME"
        export GITHUB_KNOWN_HOSTS="github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk="
        EOF

        chmod 700 baas_host_vars.sh
        echo "baas remote host created: $BAAS_HOST_NAME"

  - command: shell.exec
    params:
      working_dir: realm-core
      shell: bash
      background: true
      script: |-
        set -o errexit
        set -o pipefail
        set -o verbose

        if [[ -n "${disable_tests_against_baas|}" ]]; then
          exit 0
        fi

        BAAS_USER=ubuntu

        OPT_BAAS_BRANCH=
        OPT_BAAS_PROXY=
        OPT_BAAS_DIRECT=

        if [ -n "${baas_branch}" ]; then
            OPT_BAAS_BRANCH="-b ${baas_branch}"
        fi
        if [ -n "${baas_proxy}" ]; then
            OPT_BAAS_PROXY="-t"
            if [ -n "${baas_admin_port}" ]; then
                OPT_BAAS_DIRECT="-d ${baas_admin_port}"
            fi
        fi

        # Run the setup_baas_host_local.sh script to configure and run baas on the remote host
        # Add -v to this command for verbose script logging
        ./evergreen/setup_baas_host_local.sh -w ./baas-work-dir -u $BAAS_USER $OPT_BAAS_BRANCH $OPT_BAAS_PROXY \
            $OPT_BAAS_DIRECT -i ./.baas_ssh_key ./baas_host_vars.sh 2>&1 | tee install_baas_output.log

  "wait for baas to start":
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: bash
      script: |-
        set -o errexit
        set -o verbose

        if [[ -n "${disable_tests_against_baas|}" ]]; then
          exit 0
        fi

        # Don't print out the tail of the log file
        ./evergreen/wait_for_baas.sh -s -w ./baas-work-dir -l ""

        echo "Baas is started!"

  "wait for remote baas to start":
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: bash
      script: |-
        set -o errexit
        set -o verbose

        if [[ -n "${disable_tests_against_baas|}" ]]; then
          exit 0
        fi

        # Don't print out the tail of the log file
        ./evergreen/wait_for_remote_baas.sh -i ./.baas_ssh_key ./baas_host_vars.sh  ./.baas_ssh_key

        echo "Baas is started!"

  "setup proxy parameters":
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: bash
      script: |-
        set -o errexit
        set -o pipefail
        set -o verbose

        if [[ -n "${disable_tests_against_baas|}" ]]; then
          echo "Error: Baas is disabled for network tests"
          exit 1
        fi

        if [[ -z "${proxy_toxics_file|}" ]]; then
          echo "Error: Baas proxy toxics config file was not provided"
          exit 1
        fi

        if [[ -n "${proxy_toxics_randoms|}" ]]; then
          PROXY_RANDOMS="-r ${proxy_toxics_randoms}"
        fi

        # Configure the toxics for the baas proxy
        evergreen/configure_baas_proxy.sh $PROXY_RANDOMS "${proxy_toxics_file}"
        # Display the list of configured toxics
        curl --silent http://localhost:8474/proxies/baas_proxy/toxics

  "check branch state":
  - command: shell.exec
    type: setup
    params:
      working_dir: realm-core
      shell: bash
      script: |-
        set -o errexit
        set -o pipefail
        set -o verbose

        if [[ -n "${disable_tests_against_baas|}" ]]; then
          exit 0
        fi

        # Fail the test if local/evergreen object store tests are defined and this is not a patch build
        if [[ -f "build/objstore-tests.do-not-commit" ]]; then
            if [[ -z "${is_patch}" ]]; then
              echo "ERROR: Found custom object store tests for non-patch build"
              echo "- Revert test/object-store/objstore-tests.do-not-commit and recommit"
              exit 1
            else
              echo "WARNING: Custom object store tests are configured for this patch build"
              echo "- Revert test/object-store/objstore-tests.do-not-commit before merging PR"
            fi
        fi

timeout:
  - func: "run hang analyzer"

tasks:
- name: compile
  exec_timeout_secs: 1800
  tags: [ "for_pull_requests" ]
  commands:
  - func: "compile"

- name: package
  exec_timeout_secs: 1800
  commands:
  - func: "compile"
  - command: shell.exec
    params:
      working_dir: realm-core
      script: |-
        set -o errexit
        cpack=$(pwd)/${cmake_bindir}/cpack

        cd build
        $cpack -C ${cmake_build_type|Debug} -G TGZ -D "CPACK_PACKAGE_FILE_NAME=realm-core-artifacts" ${package_flags|}
  - command: s3.put
    params:
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      remote_file: '${project}/${branch_name}/${task_id}/${execution}/realm-core-artifacts-devel.tar.gz'
      bucket: mciuploads
      permissions: public-read
      local_file: 'realm-core/build/realm-core-artifacts-devel.tar.gz'
      content_type: '${content_type|application/x-gzip}'
  - command: s3.put
    params:
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      remote_file: '${project}/${branch_name}/${task_id}/${execution}/realm-core-artifacts-runtime.tar.gz'
      bucket: mciuploads
      permissions: public-read
      local_file: 'realm-core/build/realm-core-artifacts-runtime.tar.gz'
      content_type: '${content_type|application/x-gzip}'

- name: swift-build-and-test
  exec_timeout_secs: 1800
  tags: [ "for_pull_requests" ]
  commands:
  - func: "fetch source"
  - func: "fetch binaries"
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: /bin/bash
      script: |-
        #!/bin/bash
        set -o errexit
        set -o pipefail
        set -o verbose

        if [ -n "${xcode_developer_dir}" ]; then
            export DEVELOPER_DIR="${xcode_developer_dir}"
        fi

        xcrun swift build
        xcrun swift run ObjectStoreTests

- name: validate-installed-headers
  exec_timeout_secs: 1800
  tags: [ "for_pull_requests" ]
  commands:
  - func: "fetch source"
  - func: "fetch binaries"
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: /bin/bash
      script: |-
        #!/bin/bash
        set -o errexit
        set -o pipefail
        set -o verbose

        if [ -n "${xcode_developer_dir}" ]; then
            export DEVELOPER_DIR="${xcode_developer_dir}"
        fi

        ./tools/build-cocoa.sh -bm
        find core/include/realm -name '*.hpp' -print0 | xargs -0 -P "${max_jobs}" -n 1 clang++ -c -o /dev/null -Icore/include -std=c++17

- name: test-on-exfat
  exec_timeout_secs: 2700
  commands:
  - func: "fetch source"
  - func: "fetch binaries"
  - func: "compile"
  - command: shell.exec
    params:
      working_dir: realm-core/build
      shell: /bin/bash
      script: ../tools/run-tests-on-exfat.sh

- name: valgrind
  exec_timeout_secs: 14400
  tags: [ "for_nightly_tests" ]
  allowed_requesters: [ "ad_hoc", "patch" ]
  commands:
  - func: "fetch source"
  - func: "fetch binaries"
  - func: "compile"
    vars:
      target_to_build: "CoreTests"
  - command: shell.exec
    params:
      working_dir: realm-core/build/test
      shell: /bin/bash
      script: |-
        export UNITTEST_PROGRESS=1
        export UNITTEST_THREADS=1
        valgrind --tool=memcheck --leak-check=full --undef-value-errors=yes --track-origins=yes --child-silent-after-fork=no --trace-children=yes --suppressions=$(pwd)/../../test/valgrind.suppress --error-exitcode=1 --max-threads=5000 ./RelWithDebInfo/realm-tests

- name: bloaty
  exec_timeout_secs: 1800
  commands:
  - func: "fetch source"
  - func: "fetch binaries"
  - func: "compile"
    vars:
      target_to_build: RealmFFI
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: /bin/bash
      script: |-
        #!/bin/bash
        set -o errexit
        set -o pipefail

        mkdir bloaty-binaries && cd bloaty-binaries
        curl --silent -L ${bloaty_url} | tar -xz --strip-components=1
        BLOATY=$(pwd)/bin/bloaty
        cd ..

        FILES_TO_ANALYZE="./build/src/realm/object-store/c_api/${cmake_build_type|Debug}/librealm-ffi.so"

        mkdir bloaty-results
        for input_path in $FILES_TO_ANALYZE; do
            input_file=$(basename $input_path)
            $BLOATY -d shortsymbols $input_path -n 0 --csv > "bloaty-results/$input_file-shortsymbols.csv"
            $BLOATY -d sections $input_path -n 0 --csv > "bloaty-results/$input_file-sections.csv"
            $BLOATY -d shortsymbols $input_path -n 0 > "bloaty-results/$input_file-shortsymbols.txt"
            $BLOATY -d sections $input_path -n 0 > "bloaty-results/$input_file-sections.txt"
            $BLOATY -d compileunits $input_path -n 0 > "bloaty-results/$input_file-compileunits.txt"
            $BLOATY -d compileunits $input_path -n 0 --csv > "bloaty-results/$input_file-compileunits.csv"

            echo "Bloaty sections output for $input_file"
            head -n 100 "bloaty-results/$input_file-sections.txt"
            echo
            echo "Bloaty compile units output for $input_file"
            head -n 100 "bloaty-results/$input_file-compileunits.txt"
            echo
            echo "Bloaty short symbols output for $input_file"
            head -n 100 "bloaty-results/$input_file-shortsymbols.txt"

            ${python3|} ./evergreen/bloaty_to_json.py \
                --short-symbols-input="bloaty-results/$input_file-shortsymbols.csv" \
                --sections-input="bloaty-results/$input_file-sections.csv" \
                --compileunits-input="bloaty-results/$input_file-compileunits.csv" \
                --analyzed-file=$input_file \
                --output "bloaty-results/$input_file-results.json" \
                --project=${project} \
                --execution=${execution} \
                --is-patch=${is_patch} \
                --build-variant=${build_variant} \
                --branch=${branch_name} \
                --revision=${revision} \
                --task-id=${task_id} \
                --task-name=${task_name} \
                --revision-order-id=${revision_order_id} \
                --version-id=${version_id}

            # TODO(JBR) This is pointing to a test application for now. When we have charts configured we can create
            # a real realm app to house them and this URL will change.
            curl \
                -H "Content-Type: application/json" \
                -d "@bloaty-results/$input_file-results.json" \
                https://us-east-1.aws.webhooks.mongodb-realm.com/api/client/v2.0/app/application-0-htnkr/service/http1/incoming_webhook/upload_bloaty_results?secret=${bloaty_secret}
        done

  - command: s3.put
    params:
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      local_files_include_filter:
        - realm-core/bloaty-results/*.csv
      remote_file: '${project}/${branch_name}/${task_id}/${execution}/bloaty-results-'
      bucket: mciuploads
      permissions: public-read
      content_type: text/csv
      display_name: bloaty-results
  - command: s3.put
    params:
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      local_files_include_filter:
        - realm-core/bloaty-results/*.txt
      remote_file: '${project}/${branch_name}/${task_id}/${execution}/bloaty-results-'
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: bloaty-results
  - command: s3.put
    params:
      aws_key: '${artifacts_aws_access_key}'
      aws_secret: '${artifacts_aws_secret_key}'
      local_files_include_filter:
        - realm-core/bloaty-results/*.json
      remote_file: '${project}/${branch_name}/${task_id}/${execution}/bloaty-results-'
      bucket: mciuploads
      permissions: public-read
      content_type: application/json
      display_name: bloaty-results

- name: long-running-core-tests
  tags: [ "for_nightly_tests" ]
  allowed_requesters: [ "ad_hoc", "patch" ]
  # The long-running tests can take a really long time on Windows, so we give the test up to 4
  # hours to complete
  exec_timeout_secs: 14400
  commands:
  - func: "run tests"
    vars:
      test_filter: CoreTests

- name: core-tests
  tags: [ "test_suite", "for_pull_requests" ]
  exec_timeout_secs: 1800
  commands:
  - func: "compile"
    vars:
      target_to_build: "CoreTests"
  - func: "run tests"
    vars:
      test_filter: CoreTests
      test_executable_name: "realm-tests"

- name: benchmark-common-tasks
  exec_timeout_secs: 1800
  tags: [ "benchmark" ]
  commands:
  - func: "run benchmark"
    vars:
      benchmark_name: common-tasks

- name: benchmark-crud
  exec_timeout_secs: 1800
  tags: [ "benchmark" ]
  commands:
  - func: "run benchmark"
    vars:
      benchmark_name: crud

- name: benchmark-sync
  exec_timeout_secs: 1800
  tags: [ "benchmark" ]
  commands:
  - func: "run benchmark"
    vars:
      benchmark_name: sync

- name: sync-tests
  tags: [ "test_suite", "for_pull_requests" ]
  exec_timeout_secs: 1800
  commands:
  - func: "compile"
    vars:
      target_to_build: "SyncTests"
  - func: "run tests"
    vars:
      test_filter: SyncTests
      test_executable_name: "realm-sync-tests"

# These are local object store tests; baas is not started, however some use the sync server
- name: object-store-tests
  tags: [ "for_pull_requests", "test_suite" ]
  exec_timeout_secs: 3600
  commands:
  - func: "compile"
    vars:
      target_to_build: ObjectStoreTests
  - func: "run tests"
    vars:
      test_label: objstore-local
      test_executable_name: "realm-object-store-tests"
      verbose_test_output: true
  - func: "check branch state"

# These are baas object store tests that run against baas running on a remote host
- name: baas-integration-tests
  tags: [ "test_suite", "for_pull_requests", "requires_baas" ]
  exec_timeout_secs: 3600
  commands:
  - func: "launch remote baas"
  - func: "compile"
    vars:
      target_to_build: ObjectStoreTests
  - func: "wait for remote baas to start"
  - func: "run tests"
    vars:
      test_label: objstore-baas
      test_executable_name: "realm-object-store-tests"
      verbose_test_output: true
  - func: "check branch state"

- name: baas-network-tests
  # Uncomment once tests are passing
  tags: [ "disabled" ]
  # tags: [ "for_nightly_tests" ]
  # These tests can be manually requested for patches and pull requests
  allowed_requesters: [ "ad_hoc", "patch", "github_pr" ]
  # The network tests can take a really long time, so we give the test up to 4
  # hours to complete
  exec_timeout_secs: 14400
  commands:
  - func: "launch remote baas"
    vars:
      baas_proxy: On
  - func: "compile"
    vars:
      target_to_build: ObjectStoreTests
  - func: "wait for baas to start"
  - func: "setup proxy parameters"
  - func: "run tests"
    vars:
      test_label: objstore-baas
      test_executable_name: "realm-object-store-tests"
      verbose_test_output: true
  - func: "check branch state"

- name: process_coverage_data
  tags: [ "for_pull_requests" ]
  exec_timeout_secs: 1800
  commands:
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: bash
      env:
        COVERALLS_TOKEN: "${coveralls_token}"
      script: |-
        set -o errexit
        set -o pipefail
        set -o verbose

        if [[ -n "${xcode_developer_dir}" ]]; then
            export DEVELOPER_DIR="${xcode_developer_dir}"
        fi

        if [[ -z "${enable_llvm_coverage}" ]]; then
          exit 0
        fi

        export LLVM_PROFILE_FILE="$(find ./coverage_data -name "*.profraw")"
        if [[ -z "$LLVM_PROFILE_FILE" ]]; then
          echo "No coverage data found"
          exit 1
        fi

        echo "Found coverage files: "
        find ./coverage_data -name "*.profraw"

        curl -LsS "${grcov_url}" | tar -xj
        chmod +x grcov

        if [[ -d ./clang_binaries/bin ]]; then
          LLVM_PROFDATA_DIR="$(evergreen/abspath.sh ./clang_binaries/bin)"
        elif [[ "$(uname -s)" == "Darwin" ]]; then
          LLVM_PROFDATA_PATH="$(xcrun -f llvm-profdata)"
          LLVM_PROFDATA_DIR="$(dirname $LLVM_PROFDATA_PATH)"
        else
          echo "Missing path to clang binaries."
          exit 1
        fi

        ./grcov ./coverage_data --source-dir . \
            --binary-path ./coverage_binaries \
            --llvm \
            -t coveralls+ \
            --branch \
            --ignore-not-existing \
            --llvm-path="$LLVM_PROFDATA_DIR" \
            --token="$COVERALLS_TOKEN" \
            --service-name="Evergreen" \
            --service-job-id="${task_id}" \
            --service-number="${revision_order_id}" \
            --service-pull-request="${github_pr_number}" \
            --service-flag-name="${coveralls_flag_name}" \
            --commit-sha="${github_commit}" \
            --vcs-branch="${branch_name}" \
            --ignore='build/_deps/**' \
            --ignore='build/external/**' \
            --ignore='external/**' \
            --ignore='src/external/**' \
            --ignore='src/realm/parser/generated/**' \
            --ignore='test/large_tests/**' \
            --excl-line='LCOV_EXCL_LINE|REALM_TERMINATE|REALM_UNREACHABLE' \
            --parallel \
            --output-path=coveralls_${task_name}.json

        curl -X POST https://coveralls.io/api/v1/jobs -F 'json_file=@coveralls_${task_name}.json'

- name: finalize_coverage_data
  tags: [ "for_pull_requests" ]
  depends_on:
    - name: "process_coverage_data"
      variant: "*"
      status: "*"
  commands:
    - command: shell.exec
      params:
        shell: bash
        env:
          COVERALLS_TOKEN: "${coveralls_token}"
        script: |-
          set -o errexit

          if [[ -z "${enable_llvm_coverage}" ]]; then
            exit 0
          fi

          curl -X POST \
            -H 'Content-Type: application/json' \
            -d '{
                  "payload": {
                  "build_num": "${revision_order_id}",
                  "status": "done"
                  }
                }' \
            "https://coveralls.io/webhook?repo_token=$COVERALLS_TOKEN&carryforward=macos-arm64,ubuntu-x86_64"

- name: lint
  tags: [ "for_pull_requests" ]
  exec_timeout_secs: 1800
  commands:
  - func: "fetch source"
  - func: "fetch binaries"
  - command: shell.exec
    params:
      working_dir: realm-core
      shell: bash
      script: |-
        set -o verbose
        set -o errexit

        export PATH=$(./evergreen/abspath.sh ./clang_binaries/bin):$PATH

        if [[ "${is_patch}" == "true" ]]; then
            format_ref="$(git merge-base origin/${branch_name} HEAD)"
        else
            format_ref="${revision}"
        fi

        clang-format --version

        clang_command="git clang-format -v --diff $format_ref"
        # Don't fail the task early on clang-format errors
        out=$($clang_command) && true

        echo -e "CLANG: $clang_command\n$out"

        if [[ "$out" == *"no modified files to format"* ]]; then
            exit 0
        fi
        if [[ "$out" == *"clang-format did not modify any files"* ]]; then
            exit 0
        fi

        echo "ERROR: you need to run git clang-format on your commit"
        echo "COMMAND: git clang-format -f --commit $format_ref"
        exit 1

- name: fuzzer
  tags: [ "for_nightly_tests" ]
  allowed_requesters: [ "ad_hoc", "patch" ]
  commands:
  - command: shell.exec
    params:
      working_dir: realm-core/build/test/realm-fuzzer
      shell: /bin/bash
      script: |-
        ${cmake_build_type|Debug}/realm-libfuzz -rss_limit_mb=0 -max_total_time=3600

task_groups:
- name: core_tests_group
  setup_group_can_fail_task: true
  setup_group:
  - func: "fetch source"
  - func: "fetch binaries"
  teardown_task:
  - func: "upload test results"
  timeout:
  - func: "run hang analyzer"
  tasks:
  - core-tests

# Runs object-store-tests against baas running on remote host
- name: compile_test_and_package
  max_hosts: 1
  setup_group_can_fail_task: true
  setup_group:
  - func: "fetch source"
  - func: "fetch binaries"
  teardown_task:
  - func: "upload test results"
  - func: "upload baas artifacts"
  timeout:
  - func: "run hang analyzer"
  tasks:
  - compile
  - .test_suite
  - package

# Runs core/sync/local object store tests
- name: compile_local_tests
  max_hosts: 1
  setup_group_can_fail_task: true
  setup_group:
  - func: "fetch source"
  - func: "fetch binaries"
  teardown_task:
  - func: "upload test results"
  timeout:
  - func: "run hang analyzer"
  tasks:
  - compile
  - ".test_suite !.requires_baas"

# Runs object-store-tests against baas running on remote host
- name: compile_test
  max_hosts: 1
  setup_group_can_fail_task: true
  setup_group:
  - func: "fetch source"
  - func: "fetch binaries"
  teardown_task:
  - func: "upload test results"
  - func: "upload baas artifacts"
  timeout:
  - func: "run hang analyzer"
  tasks:
  - compile
  - .test_suite

# Runs object-store-tests against baas running on remote host and runs
# the network simulation tests as a separate task for nightly builds
- name: network_tests
  max_hosts: 1
  setup_group_can_fail_task: true
  setup_group:
  - func: "fetch source"
  - func: "fetch binaries"
  teardown_task:
  - func: "upload test results"
  - func: "upload baas artifacts"
  timeout:
  - func: "run hang analyzer"
  tasks:
  - baas-network-tests

# Runs object-store-tests against baas running on remote host
- name: compile_test_coverage
  max_hosts: 1
  setup_group_can_fail_task: true
  setup_group:
  - func: "fetch source"
  - func: "fetch binaries"
  teardown_task:
  - func: "upload test results"
  - func: "upload baas artifacts"
  timeout:
  - func: "run hang analyzer"
  tasks:
  - compile
  - .test_suite
  - process_coverage_data

- name: benchmarks
  setup_group_can_fail_task: true
  setup_group:
  - func: "fetch source"
  - func: "fetch binaries"
  - func: "compile"
    vars:
      target_to_build: "benchmarks"
  timeout:
  - func: "run hang analyzer"
  tasks:
  - .benchmark

- name: long-running-tests
  setup_group_can_fail_task: true
  setup_group:
  - func: "fetch source"
  - func: "fetch binaries"
  - func: "compile"
    vars:
      long_running_test_duration: 2
      target_to_build: CoreTests
  teardown_task:
  - func: "upload test results"
  timeout:
  - func: "run hang analyzer"
  tasks:
  - long-running-core-tests

- name: fuzzer-tests
  setup_group_can_fail_task: true
  setup_group:
  - func: "fetch source"
  - func: "fetch binaries"
  - func: "compile"
    vars:
      target_to_build: realm-libfuzz
  teardown_task:
  - func: "upload fuzzer results"
  tasks:
  - fuzzer

buildvariants:
- name: ubuntu2004
  display_name: "Ubuntu 20.04 x86_64 (Clang 11)"
  run_on: ubuntu2004-large
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
    extra_flags: -DREALM_ENABLE_GEOSPATIAL=OFF # can be removed once SDKs pick this feature up
  tasks:
  - name: compile_test


- name: ubuntu2204
  display_name: "Ubuntu 22.04 x86_64 (Clang 16 + lint)"
  run_on: ubuntu2204-large
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-16.0.2-x86_64-linux-gnu-ubuntu-22.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
  tasks:
  - name: lint
    distros:
    - ubuntu2204-small
  - name: compile_test

- name: ubuntu2004-no-session-multiplexing
  display_name: "Ubuntu 20.04 x86_64 (Sync Multiplexing Disabled)"
  run_on: ubuntu2004-large
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
    disable_sync_multiplexing: On
  tasks:
  - name: compile_test

- name: ubuntu2004-encryption-tsan
  display_name: "Ubuntu 20.04 x86_64 (Clang 11 Encryption Enabled w/TSAN)"
  run_on: ubuntu2004-small
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
    run_with_encryption: On
    enable_tsan: On
    cmake_build_type: RelWithDebInfo
  tasks:
  - name: core_tests_group
    distros:
    - ubuntu2004-large

- name: ubuntu2004-encryption-asan
  display_name: "Ubuntu 20.04 x86_64 (Clang 11 Encryption Enabled w/ASAN)"
  run_on: ubuntu2004-small
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
    llvm_symbolizer: "./clang_binaries/bin/llvm-symbolizer"
    run_with_encryption: On
    enable_asan: On
    cmake_build_type: RelWithDebInfo
  tasks:
  - name: core_tests_group
    distros:
    - ubuntu2004-large

- name: ubuntu2004-release
  display_name: "Ubuntu 20.04 x86_64 (Clang 11 Release build)"
  run_on: ubuntu2004-small
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    bloaty_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/bloaty-v1.1-39-gefc1c61-ubuntu2004-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    cmake_build_type: RelWithDebInfo
    fetch_missing_dependencies: On
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
    python3: /opt/mongodbtoolchain/v3/bin/python3
  tasks:
  - name: compile_test_and_package
    distros:
    - ubuntu2004-large
  - name: benchmarks
    distros:
    - ubuntu2004-large
  - name: long-running-tests
  - name: bloaty

- name: ubuntu2004-asan
  display_name: "Ubuntu 20.04 x86_64 (Clang 11 ASAN)"
  run_on: ubuntu2004-large
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    enable_asan: On
    cmake_build_type: RelWithDebInfo
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
    llvm_symbolizer: "./clang_binaries/bin/llvm-symbolizer"
  tasks:
  - name: compile_test
  - name: long-running-tests
    distros:
    - ubuntu2004-small

- name: ubuntu2004-tsan
  display_name: "Ubuntu 20.04 x86_64 (Clang 11 TSAN)"
  run_on: ubuntu2004-large
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    enable_tsan: On
    cmake_build_type: RelWithDebInfo
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
  tasks:
  - name: compile_test

- name: ubuntu2004-ubsan
  display_name: "Ubuntu 20.04 x86_64 (Clang 11 UBSAN)"
  run_on: ubuntu2004-small
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    enable_ubsan: On
    cmake_build_type: RelWithDebInfo
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
  tasks:
  - name: compile_test
    distros:
    - ubuntu2004-large

- name: ubuntu2004-fuzzer
  display_name: "Ubuntu 20.04 x86_64 (Clang 11 Fuzzer)"
  run_on: ubuntu2004-large
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    enable_ubsan: On
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
    cmake_build_type: RelWithDebInfo
    run_with_encryption: On
    enable_fuzzer: On
  tasks:
  - name: fuzzer-tests

# disable these builders since there are constantly failing and not yet ready for nightly builds
# - name: ubuntu2004-network-nonideal
#   display_name: "Ubuntu 20.04 x86_64 (Utunbu2004 - nonideal transfer)"
#   run_on: ubuntu2004-large
#   expansions:
#     clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
#     cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
#     cmake_bindir: "./cmake_binaries/bin"
#     fetch_missing_dependencies: On
#     c_compiler: "./clang_binaries/bin/clang"
#     cxx_compiler: "./clang_binaries/bin/clang++"
#     cmake_build_type: RelWithDebInfo
#     run_with_encryption: On
#     baas_admin_port: 9098
#     test_logging_level: debug
#     test_timeout_extra: 60
#     proxy_toxics_file: evergreen/proxy-nonideal-transfer.toxics
#     # RANDOM1: bandwidth-upstream limited to between 10-50 KB/s from the client to the server
#     # RANDOM2: bandwidth-downstream limited to between 10-50 KB/s from the server to the client
#     proxy_toxics_randoms: "10:50|10:50"
#   tasks:
#   - name: network_tests
#
# - name: ubuntu2004-network-faulty
#   display_name: "Ubuntu 20.04 x86_64 (Utunbu2004 - network faults)"
#   run_on: ubuntu2004-large
#   expansions:
#     clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
#     cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
#     cmake_bindir: "./cmake_binaries/bin"
#     fetch_missing_dependencies: On
#     c_compiler: "./clang_binaries/bin/clang"
#     cxx_compiler: "./clang_binaries/bin/clang++"
#     cmake_build_type: RelWithDebInfo
#     run_with_encryption: On
#     baas_admin_port: 9098
#     test_logging_level: debug
#     proxy_toxics_file: evergreen/proxy-network-faults.toxics
#     # RANDOM1: limit-data-upstream to close connection after between 1000-3000 bytes have been sent
#     # RANDOM2: limit-data-downstream to close connection after between 1000-3000 bytes have been received
#     # RANDOM3: slow-close-upstream to keep connection to server open after 1000-1500 milliseconds after being closed
#     # RANDOM4: reset-peer-upstream after 50-200 seconds to force close the connection to the server
#     proxy_toxics_randoms: "1000:3000|1000:3000|1000:1500|50:200"
#   tasks:
#   - name: network_tests

- name: rhel70
  display_name: "RHEL 7 x86_64"
  run_on: rhel70-large
  expansions:
    c_compiler: /opt/mongodbtoolchain/v3/bin/gcc
    cxx_compiler: /opt/mongodbtoolchain/v3/bin/g++
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    curl: "/opt/mongodbtoolchain/v3/bin/curl"
    python3: "/opt/mongodbtoolchain/v3/bin/python3"
    ninja: "/opt/mongodbtoolchain/v4/bin/ninja"
  tasks:
  - name: compile_test_and_package

- name: ubuntu-valgrind
  display_name: "Ubuntu 22.04 x86_64 (Valgrind)"
  run_on: ubuntu2204-large
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    enable_valgrind: On
    cmake_build_type: RelWithDebInfo
  tasks:
  - name: valgrind

- name: ubuntu2004-arm64
  display_name: "Ubuntu 20.04 ARM64"
  run_on: ubuntu2004-arm64-large
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-aarch64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    python3: "/opt/mongodbtoolchain/v3/bin/python3"
    use_system_openssl: On
    fetch_missing_dependencies: On
    cmake_build_type: RelWithDebInfo
  tasks:
  - name: compile_test_and_package
  - name: benchmarks

# use a small runner to exercise timing sensitive bugs
- name: ubuntu2204-arm64-small
  display_name: "Ubuntu 22.04 ARM64 Small"
  run_on: ubuntu2204-arm64-small
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-aarch64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    python3: "/opt/mongodbtoolchain/v3/bin/python3"
    use_system_openssl: On
    fetch_missing_dependencies: On
    cmake_build_type: RelWithDebInfo
  tasks:
  - name: compile_test_and_package

- name: ubuntu2204-arm64-asan
  display_name: "Ubuntu 22.04 ARM64 (ASAN)"
  run_on: ubuntu2204-arm64-large
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-aarch64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    python3: "/opt/mongodbtoolchain/v3/bin/python3"
    use_system_openssl: On
    fetch_missing_dependencies: On
    cmake_build_type: Debug
    enable_asan: On
  tasks:
  - name: compile_test

- name: macos
  display_name: "MacOS 11.0 x86_64"
  run_on: macos-1100
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=x86_64
  tasks:
  - name: compile_test
  - name: swift-build-and-test
  - name: validate-installed-headers

- name: macos-encrypted
  display_name: "MacOS 11.0 x86_64 (Encryption enabled)"
  run_on: macos-1100
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=x86_64
    run_with_encryption: On
  tasks:
  - name: core_tests_group

- name: macos-release
  display_name: "MacOS 11.0 x86_64 (Release build)"
  run_on: macos-1100
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    cmake_build_type: Release
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=x86_64
  tasks:
  - name: compile_test_and_package
  - name: benchmarks
  - name: long-running-tests
  - name: swift-build-and-test
  - name: test-on-exfat

- name: macos-1100-arm64
  display_name: "MacOS 11 arm64"
  run_on: macos-1100-arm64
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=arm64 -DREALM_ENABLE_GEOSPATIAL=OFF
  tasks:
  - name: compile_test
  - name: swift-build-and-test

- name: macos-1100-arm64-release
  display_name: "MacOS 11 arm64 (Release build)"
  run_on: macos-1100-arm64
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    cmake_build_type: Release
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=arm64
  tasks:
  - name: compile_test_and_package
  - name: benchmarks
  - name: long-running-tests
  - name: swift-build-and-test

- name: macos-1100-x64-asan
  display_name: "MacOS 11.0 x86_64 (ASAN)"
  run_on: macos-1100
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=x86_64
    cmake_build_type: RelWithDebInfo
    enable_asan: On
  tasks:
  - name: compile_test

- name: macos-1100-x64-tsan
  display_name: "MacOS 11.0 x86_64 (TSAN)"
  run_on: macos-1100
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=x86_64
    cmake_build_type: RelWithDebInfo
    enable_tsan: On
  tasks:
  - name: compile_test

- name: macos-1100-arm64-asan
  display_name: "MacOS 11 arm64 (ASAN)"
  run_on: macos-1100-arm64
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=arm64
    cmake_build_type: RelWithDebInfo
    enable_asan: On
  tasks:
  - name: compile_test

- name: macos-1100-arm64-tsan
  display_name: "MacOS 11 arm64 (TSAN)"
  run_on: macos-1100-arm64
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=arm64
    cmake_build_type: RelWithDebInfo
    enable_tsan: On
  tasks:
  # FIXME: tsan is not stable on arm64, fails often with internal errors
  # - name: compile_test
  - name: compile_test

- name: macos-coverage
  display_name: "MacOS 11 arm64 (Code Coverage)"
  run_on: macos-1100-arm64
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-macos-universal.tar.gz"
    cmake_bindir: "./cmake_binaries/CMake.app/Contents/bin"
    cmake_toolchain_file: "./tools/cmake/xcode.toolchain.cmake"
    cmake_generator: Xcode
    max_jobs: $(sysctl -n hw.logicalcpu)
    xcode_developer_dir: /Applications/Xcode13.1.app/Contents/Developer
    extra_flags: -DCMAKE_SYSTEM_NAME=Darwin -DCMAKE_OSX_ARCHITECTURES=arm64
    enable_llvm_coverage: On
    coveralls_flag_name: "macos-arm64"
    grcov_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/grcov-aarch64-apple-darwin.tar.bz2"
  tasks:
  - name: compile_test_coverage

- name: ubuntu-coverage
  display_name: "Ubuntu 20.04 x86_64 (Code Coverage)"
  run_on: ubuntu2004-large
  expansions:
    clang_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/clang%2Bllvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-linux-x86_64.tar.gz"
    cmake_bindir: "./cmake_binaries/bin"
    fetch_missing_dependencies: On
    c_compiler: "./clang_binaries/bin/clang"
    cxx_compiler: "./clang_binaries/bin/clang++"
    enable_llvm_coverage: On
    coveralls_flag_name: "ubuntu-x86_64"
    grcov_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/grcov-x86_64-unknown-linux-gnu.tar.bz2"
  tasks:
  - name: compile_test_coverage
  - name: finalize_coverage_data

- name: windows-64-vs2019
  display_name: "Windows x86_64 (VS 2019)"
  run_on: windows-vsCurrent-large
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-windows-x86_64.zip"
    cmake_bindir: "./cmake-3.26.3-windows-x86_64/bin"
    cmake_generator: "Visual Studio 16 2019"
    extra_flags: "-A x64"
    max_jobs: $(($(grep -c proc /proc/cpuinfo) / 2))
    fetch_missing_dependencies: On
    curl_base: "/cygdrive/c/curl"
    python3: "/cygdrive/c/python/python37/python.exe"
  tasks:
  - name: compile_test

- name: windows-64-encryption
  display_name: "Windows x86_64 (Encryption enabled)"
  run_on: windows-vsCurrent-large
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-windows-x86_64.zip"
    cmake_bindir: "./cmake-3.26.3-windows-x86_64/bin"
    cmake_generator: "Visual Studio 16 2019"
    extra_flags: "-A x64"
    max_jobs: $(($(grep -c proc /proc/cpuinfo) / 2))
    fetch_missing_dependencies: On
    curl_base: "/cygdrive/c/curl"
    python3: "/cygdrive/c/python/python37/python.exe"
    run_with_encryption: On
  tasks:
  - name: core_tests_group

- name: windows-64-vs2019-release
  display_name: "Windows x86_64 (VS 2019 Release build)"
  run_on: windows-vsCurrent-large
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-windows-x86_64.zip"
    cmake_bindir: "./cmake-3.26.3-windows-x86_64/bin"
    cmake_generator: "Visual Studio 16 2019"
    extra_flags: "-A x64"
    cmake_build_type: "Release"
    max_jobs: $(($(grep -c proc /proc/cpuinfo) / 2))
    fetch_missing_dependencies: On
    curl_base: "/cygdrive/c/curl"
    python3: "/cygdrive/c/python/python37/python.exe"
  tasks:
  - name: compile_test_and_package
  - name: long-running-tests

- name: windows-64-vs2019-asan
  display_name: "Windows x86_64 (VS 2019 ASAN)"
  run_on: windows-vsCurrent-large
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-windows-x86_64.zip"
    cmake_bindir: "./cmake-3.26.3-windows-x86_64/bin"
    cmake_generator: "Visual Studio 16 2019"
    extra_flags: "-A x64"
    cmake_build_type: "Debug"
    enable_asan: On
    max_jobs: $(($(grep -c proc /proc/cpuinfo) / 2))
    fetch_missing_dependencies: On
    curl_base: "/cygdrive/c/curl"
    python3: "/cygdrive/c/python/python37/python.exe"
  tasks:
  - name: compile_test

- name: windows-x86-release
  display_name: "Windows X86 (Release)"
  run_on: windows-vsCurrent-large
  expansions:
    cmake_url: "https://s3.amazonaws.com/static.realm.io/evergreen-assets/cmake-3.26.3-windows-x86_64.zip"
    cmake_bindir: "./cmake-3.26.3-windows-x86_64/bin"
    cmake_generator: "Visual Studio 16 2019"
    cmake_generator_platform: "Win32"
    cmake_build_type: "Release"
    max_jobs: $(($(grep -c proc /proc/cpuinfo) / 2))
    fetch_missing_dependencies: On
    python3: "/cygdrive/c/python/python37/python.exe"
    disable_tests_against_baas: On
  tasks:
  - name: compile_local_tests

